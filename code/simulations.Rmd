---
title: "Simulations"
author: "mira"
date: "2022/6/12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Method performance on linear/ heteroskadestic/ spatial non-stationary data are demonstrated. The measure of performance is coverage (the rate at which the prediction interval correctly cover the true outcome). Average coverage is computed by repeating the experiment 100 times. Conditional coverage is coverage conditional on X values, it can also be calculated from results of the repeated experiments, although more runs are needed. Conformalised quantile regression provides better conditional coverage as the predicton intervals are adaptive to X. In comparison, conformalised mean prediction models produce same length intervals for all X, so conditional coverage may be poor even if average coverage achieves the target level.


# Generating non-spatial data

```{r}
library(gstat)
library(fields)
library(sp)
library(igraph)
library(tidyverse)
library(ggplot2)
```

## linear
```{r data_ns_1 }
# non-spatial data, 
# linear treatment effect.
set.seed(123)
n <- 1000
d <- 5
X_ns_1 <- matrix(rnorm(n * d), nrow = n) # V1-V5
beta_ns_1 <- rep(1, 5)
Y1_ns_1 <- X_ns_1 %*% beta_ns_1 + rnorm(n)
# plot(X_ns_1[, 1],Y1_ns_1)
#hist(Y1_ns_1)
Y0_ns_1 <- rnorm(n)
ps_ns_1 <- pnorm(X_ns_1[, 1]) # one confounder
# ps_ns_1 <- (1 + pbeta(X_ns_1[, 1], 2, 4)) / 4
# hist(ps_ns_1)
# plot(X_ns_1[, 1],ps_ns_1)
T_ns_1 <- sapply(ps_ns_1,function(x){rbinom(1,1,prob=x)})
# hist(T_ns_1)
# plot(X_ns_1[, 1],T_ns_1)
Y_ns_1 <- ifelse(T_ns_1 == 1, Y1_ns_1, Y0_ns_1)
# plot(Y0_ns_1,Y_ns_1)
save(Y_ns_1,Y1_ns_1,Y0_ns_1,X_ns_1,T_ns_1,ps_ns_1,file="datans1.Rdata")
```

## heteroskadestic and non-linear
The covariates $X_{ij}$ are i.i.d. generated from $\mathrm{Unif}([0, 1])$ , $Y_{i}(0)=\epsilon_{i}$, $\mathbb{E}[Y_{i}(1) \mid X_{i}] = f(X_{i1})f(X_{i2})$ , where $f(x) = \frac{2}{1 + \exp(-12(x - 0.5))}$. $Y_{i}(1) = \mathbb{E}[Y_{i}(1) \mid X_{i}] + \epsilon_{i}$ where $\epsilon_{i}\stackrel{i.i.d.}{\sim}N(0, 1)$. 

The propensity score $e(x)=P(T_{i} = 1\mid X_{i} = x)$ is set as $e(x) = \frac{1}{4}(1 + \beta_{2, 4}(x))$ where $\beta_{2, 4}(x)$ is the cdf of the Beta-distribution with parameters 2 and 4.
```{r data_ns_2}
# non-spatial data, 
# heteroskadestic.
set.seed(123)
n <- 1000
d <- 5
X_ns_2 <- X_ns_1 
genY_ns_2 <- function(X){
  2 / (1+exp(-12*(X[, 1]-0.5)))*2/(1+exp(-12*(X[, 2]-0.5)))+rnorm(n)
  }
Y1_ns_2 <- genY_ns_2(X_ns_2) 
# hist(Y1_ns_2)
# plot(X_ns_2[, 1],Y1_ns_2)
Y0_ns_2 <- rnorm(n)
ps_ns_2 <- (1 + pbeta(X_ns_2[, 1], 2, 4)) / 4
T_ns_2 <- sapply(ps_ns_2,function(x){rbinom(1,1,prob=x)}) 
# plot(X_ns_2[, 1],T_ns_2)
# T_ns_2 <- map_dbl(1:n,function(x){rbernoulli(n=1,ps_ns_2[x])}) 
# T_ns_2 <- as.numeric(ps_ns_2 > runif(n)) 
Y_ns_2 <- ifelse(T_ns_2 == 1, Y1_ns_2, Y0_ns_2)
# plot(Y0_ns_2,Y_ns_2)
save(Y_ns_2,Y1_ns_2,Y0_ns_2,X_ns_2,T_ns_2,ps_ns_2,file="datans2.Rdata")
```


# generating network (spatial) data with interference

##  net1. Map data_ns_1 to random network. save potential outcomes.
```{r}
n <- 1000
# generate net1 and map data_ns_1 to net1
# net1 <- sample_gnp(n,p=0.1,directed=FALSE,loops=FALSE) # non-spatial graph
net1<-igraph::sample_grg(n,radius=0.05,torus=FALSE,coords=TRUE) # spatial graph
# saveRDS(net1,file="net1_structure.Rdata") 
# plot(net1,vertex.size = 3,vertex.label = NA)
# hist(degree(net1)) # mostly between 2-12 first-order neighbours
g1 <- igraph::as_data_frame(net1,what="vertices")# coords in (x, y)
colnames(g1)<-c("coordx","coordy")
g1$Z <- T_ns_1
g1$YZ <-Y_ns_1
g1$G <- 0
g1$YG <- 0
for (i in 1:n){
    neigh = igraph::neighbors(net1,v = i)
    g1$G[i] =  mean(g1$Z[neigh]) # mean exposure, can also use inverse dist w
    g1$YG[i] =0.2*mean(g1$YZ[neigh]) # neighborhood spillover YG
}
#hist(g1$YG)

# all POs. technically speaking this is a bit problematic...
YG1_nt_1<-g1$YG
YG0_nt_1<-0
YZ1_nt_1<-Y1_ns_1
YZ0_nt_1<-Y0_ns_1

Y00_nt_1<-YZ0_nt_1+YG0_nt_1
Y01_nt_1<-YZ0_nt_1+YG1_nt_1
Y10_nt_1<-YZ1_nt_1+YG0_nt_1
Y11_nt_1<-YZ1_nt_1+YG1_nt_1

# actual outcome
g1$YG <- ifelse(g1$G >0.5, g1$YG, 0)
Y_nt_1<-g1$YZ+g1$YG # add interference. effects from Z & G assumed additive.
#hist(Y_nt_1)

X_nt_1<-X_ns_1
A_adj<-as_adjacency_matrix(net1)
Z_nt_1<-g1$Z
G_nt_1<-ifelse(g1$G >0.5, 1, 0)
T_nt_1<-paste0(Z_nt_1,G_nt_1)

# Compute gps later and check balance.
save(Y00_nt_1,Y01_nt_1,Y10_nt_1,Y11_nt_1,Y_nt_1,X_nt_1,Z_nt_1,G_nt_1,T_nt_1,file="datanet1.Rdata")
```


##  net2. Map data_ns_2 to same random network as net1.save potential outcomes.
```{r}
# map data_ns_2 to net1, with updated Z, G, YZ, YG, Y
g2<-g1
g2$Z <- T_ns_2
g2$YZ <-Y_ns_2
g2$G <- 0
g2$YG <- 0
for (i in 1:n){
    neigh = igraph::neighbors(net1,v = i)
    g2$G[i] =  mean(g2$Z[neigh]) 
    g2$YG[i] =0.2*mean(g2$YZ[neigh]) 
}
# all POs.
YG1_nt_2<-g2$YG
YG0_nt_2<-0
YZ1_nt_2<-Y1_ns_2
YZ0_nt_2<-Y0_ns_2

Y00_nt_2<-YZ0_nt_2+YG0_nt_2
Y01_nt_2<-YZ0_nt_2+YG1_nt_2
Y10_nt_2<-YZ1_nt_2+YG0_nt_2
Y11_nt_2<-YZ1_nt_2+YG1_nt_2

# actual outcome
g2$YG <- ifelse(g2$G >0.5, g2$YG, 0)

Y_nt_2<-g2$YZ+g2$YG 
X_nt_2<-X_ns_2
# A_adj 
Z_nt_2<-g2$Z
G_nt_2<-ifelse(g2$G >0.5, 1, 0)
T_nt_2<-paste0(Z_nt_2,G_nt_2)
save(Y00_nt_2,Y01_nt_2,Y10_nt_2,Y11_nt_2,Y_nt_2,X_nt_2,Z_nt_2,G_nt_2,T_nt_2,file="datanet2.Rdata")
```

## net3. add spatial non-stationarity in y=f_beta(x) to net2 outcome YZ.
```{r}
set.seed(123)
# outcome Y_i(Z=1) is dependent on location of i ,
# in the form of spatially varying coeff in generating Y(Z=1)
grid <- expand.grid(1:100, 1:100)
names(grid)<-c("x","y")

# spatial trend
g.dummy1 <- gstat(formula=z~1+x+y, locations=~x+y, dummy=T, beta=c(1,0.01,0.005), model=vgm(psill=0.025, range=15, model='Exp'), nmax=20)
# random clustering
g.dummy2 <- gstat(formula=z~1, locations=~x+y, dummy=T, beta=c(1,0.01,0.005), model=vgm(psill=0.025, range=15, model='Exp'), nmax=20)

coeff_grid <- predict(g.dummy1, newdata=grid, nsim=4)
sp::gridded(coeff_grid) = ~x+y
# saveRDS(coeff_grid,file="coeff_grid.Rdata") 
# spplot(coeff_grid)
sim<-data.frame(coeff_grid$sim1,coeff_grid$sim2,coeff_grid@coords)
colnames(sim)<-c("coeff1","coeff2","x","y")
sim$xy<-paste0(sim$x,"-",sim$y)

coeff<-data.frame(floor(g1$coordx*100)+1,floor(g1$coordy*100)+1)
colnames(coeff)<-c("x","y")
coeff$xy<-paste0(coeff$x,"-",coeff$y)
coeff<-left_join(coeff,sim[,c(1,2,5)],by="xy")

# sanity checks
# mapcheck<-cbind.data.frame(coeff$x,coeff$y,X_ns_1,Z_nt_3,G_nt_3,Y_nt_3)
# ggplot(coeff,aes(x=x,y=y,color=coeff1))+geom_point(size=3)+scale_colour_gradient2()

genY_nt_3 <- function(X){
  2 / (1 + exp(coeff$coeff1*(X[, 1]-0.5)))*2/(1 + exp(-1 *(X[, 2] - 0.5)))+rnorm(n)
}
YZ1_nt_3 <- genY_nt_3(X_ns_2) 
# hist(Y1_nt_3)
# plot(X_ns_2[,1],Y1_nt_3)
YZ_nt_3 <- ifelse(T_ns_2 == 1, YZ1_nt_3, Y0_ns_2)
# copy net1, with updated YZ, YG, Y
g3<-g1
g3$YZ <-YZ_nt_3
for (i in 1:n){
    neigh = igraph::neighbors(net1,v = i)
    g3$YG[i] =0.2*mean(g3$YZ[neigh])
}
# all POs.
YG1_nt_3<-g3$YG
YG0_nt_3<-0
#YZ1_nt_3
YZ0_nt_3<-Y0_ns_2

Y00_nt_3<-YZ0_nt_3+YG0_nt_3
Y01_nt_3<-YZ0_nt_3+YG1_nt_3
Y10_nt_3<-YZ1_nt_3+YG0_nt_3
Y11_nt_3<-YZ1_nt_3+YG1_nt_3

# actual outcome
g3$YG <- ifelse(g3$G >0.5, g3$YG, 0)

Y_nt_3<-g3$YZ+g3$YG
X_nt_3<-X_ns_2
# A_adj
Z_nt_3<-g3$Z
G_nt_3<-ifelse(g3$G >0.5, 1, 0)
T_nt_3<-paste0(Z_nt_3,G_nt_3)
save(Y00_nt_3,Y01_nt_3,Y10_nt_3,Y11_nt_3,Y_nt_3,X_nt_3,Z_nt_3,G_nt_3,T_nt_3,file="datanet3.Rdata")
```


(4) net4. With network autocorrelation. This may affect the conformal prediction. Otherwise it should not make a difference for causal identification, since we assume conditional ignorability.
```{r}

```


# testing the estimation of GPS

```{r testid}
# testing point, one index from 1:n
testid0<- sample(n,1)
```


```{r test1}
# binary treatment, 4 level exposure, getting GPS and test balance
A<-as.matrix(A_adj)
test1_gps1 <- get_gps1(tr = Z_nt_1,covar = X_nt_1,A = A,Atype="adj",
                    pstype="joint",ps_pred_model="binomial")
# true and estimated p(z=1)
plot(ps_ns_1,test1_gps1[,5],xlab="True GPS",ylab="Estimated GPS")
# check balance

```


# Testing standard split conformal prediction

```{r test2,  include=TRUE, eval=FALSE}
# generate null equal weights and random trainid
test2_wt<-rep(1,n)
test2_trainid<-sample(n,floor(n*0.6))
# Run standard plit conformal
test2_pred <- conformalSplit(X=X_ns_1, Y=X_ns_1, testid=testid0,
                          outfun="quantRF", 
                          wt=test2_wt,
                          trainid=test2_trainid,
                          alpha=0.1)
```


# Testing spatial conformal 

## testing the counterfactual prediction
```{r test3_trainid}
test3_trainid <- test4_trainid <- test5_trainid <- test2_trainid
# generate different trainid, if desired.
```


```{r}
# generate gps
ps_nt_1 <-test1_gps1

ps_nt_2 <- get_gps1(tr = Z_nt_2,covar = X_nt_2, A = A,Atype="adj",
                    pstype="joint",ps_pred_model="binomial")
ps_nt_3 <- get_gps1(tr = Z_nt_3,covar = X_nt_3,A = A,Atype="adj",
                    pstype="joint",ps_pred_model="binomial")
```


spatial linear
```{r test3}
# spatial CF for counterfactual prediciton
test3_pred<-conformalCf_split(X=X_nt_1, Y=Y_nt_1, 
                              testid=testid0,
                              tl=T_nt_1,
                              outfun="quantRF", 
                              wt=ps_nt_1,trainid=test3_trainid)
```

spatial heteroskadestic
```{r test4}
# spatial CF for counterfactual prediciton
test4_pred<-conformalCf_split(X=X_nt_2, Y=Y_nt_2, 
                              testid=testid0,
                              tl=T_nt_2,
                              outfun="quantRF", 
                              wt=ps_nt_2,trainid=test5_trainid)
```

spatial heteroskadestic, non-stationary
```{r test5}
# spatial CF for counterfactual prediciton
test5_pred<-conformalCf_split(X=X_nt_3, Y=Y_nt_3, 
                              testid=testid0,
                              tl=T_nt_3,
                              outfun="quantRF", 
                              wt=ps_nt_3,trainid=test5_trainid)
```


## testing the spatial ITE construction

computing coverage rate
For computing coverage, experiments are rerun 100 times. Plot the confidence intervals against true value as summary the coverage.
We compute coverage rates on the main advertised scenarios: 
test6 (spatial linear) 
test7 (spatial heteroskadestic) 
test8 (spatial heteroskadestic non-stationary).

Note that spatial confounding / unmeasured confounding is not covered by the proposed method.

```{r compute_coverage}
# compute_coverage function is used to repeat certain experiments
# The function resamples from 1:n to get a testid and run the main fuctions with it.
# iter            number of times to repeat the experiment.
# data_type       "network", "spatial" datasets
# experiment_id   which experiment to run, "test6", "test7", "test8"

compute_coverage<-function(X, Y,
                          tr,
                          A, typeA,
                          ps_pred_model="binomial",
                          outfun, outparams,
                          iter,
                          data_type,
                          experiment_id){
  if (iter>100){iter=100}
  results<-list()
  n<-length(Y)
  if (data_type="network"){
    params<- list(A=A,typeA="adj",ps_pred_model="binomial",outfun="quantRF")
    if (experiment_id="text6"){
      for (i in 1:iter){
      testid0<-sample(n,1)
      results[i]<-do.call(conformal_ITE1,c(params,X=X_nt_1, Y=Y_nt_1,testid=testid0,
                                           tr=Z_nt_1,))
      }
    } else if (experiment_id="text7"){
      for (i in 1:iter){
      testid0<-sample(n,1)
      results[i]<-do.call(conformal_ITE1.c(params,X=X_nt_2, Y=Y_nt_2,testid=testid0,
                                           tr=Z_nt_2))
      }
    } else if (experiment_id="text8"){
      for (i in 1:iter){
      testid0<-sample(n,1)
      results[i]<-do.call(conformal_ITE1,c(params,X=X_nt_3, Y=Y_nt_3, testid=testid0,
                                           tr=Z_nt_3,))
      }
    }
  } else if (data_type="spatial") {
    params<- list(A=A_adj,typeA="adj",ps_pred_model="binomial",outfun="quantRF")
    if (experiment_id="text6"){
      for (i in 1:iter){
      testid0<-sample(n,1)
      results[i]<-do.call(conformal_ITE1,c(params,X=X_nt_1, Y=Y_nt_1,testid=testid0,
                                           tr=Z_nt_1,))
      }
    } else if (experiment_id="text7"){
      for (i in 1:iter){
      testid0<-sample(n,1)
      results[i]<-do.call(conformal_ITE1.c(params,X=X_nt_2, Y=Y_nt_2,testid=testid0,
                                           tr=Z_nt_2))
      }
    } else if (experiment_id="text8"){
      for (i in 1:iter){
      testid0<-sample(n,1)
      results[i]<-do.call(conformal_ITE1,c(params,X=X_nt_3,Y=Y_nt_3,testid=testid0,
                                           tr=Z_nt_3,))
      }
    }
  }
 return(results)
}
```


# plotting spatial conformal outcomes


```{r plot1}
# plotting coverage of expriments
```

