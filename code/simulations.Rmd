---
title: "Simulations"
author: "mira"
date: "2022/6/12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Method performance on linear/ heteroskadestic/ spatial non-stationary data are demonstrated. The measure of performance is coverage (the rate at which the prediction interval correctly cover the true outcome). Average coverage is computed by repeating the experiment 100 times. Conditional coverage is coverage conditional on X values, it can also be calculated from results of the repeated experiments, although more runs are needed. Conformalised quantile regression provides better conditional coverage as the predicton intervals are adaptive to X. In comparison, conformalised mean prediction models produce same length intervals for all X, so conditional coverage may be poor even if average coverage achieves the target level.


# Generating non-spatial data

```{r}
library(gstat)
library(fields)
library(sp)
library(igraph)
library(tidyverse)
library(ggplot2)
library(viridis)
library(grf)
library(gbm)
library(randomForest)
library(bartMachine)
library(xgboost)
library(nnet)
library(blockCV)
```


```{r}
source("utils.R")
# source("gps_weightedconformal.R")
```

## linear
```{r data_ns_1 }
# non-spatial data, 
# linear treatment effect.
set.seed(123)
n <- 1000
d <- 5
X_ns_1 <- matrix(rnorm(n * d), nrow = n) # V1-V5
beta_ns_1 <- rep(1, 5)
Y1_ns_1 <- X_ns_1 %*% beta_ns_1 + rnorm(n)
# plot(X_ns_1[, 1],Y1_ns_1)
#hist(Y1_ns_1)
Y0_ns_1 <- rnorm(n)
ps_ns_1 <- pnorm(X_ns_1[, 1]) # one confounder
# ps_ns_1 <- (1 + pbeta(X_ns_1[, 1], 2, 4)) / 4
# hist(ps_ns_1)
# plot(X_ns_1[, 1],ps_ns_1)
T_ns_1 <- sapply(ps_ns_1,function(x){rbinom(1,1,prob=x)})
# hist(T_ns_1)
# plot(X_ns_1[, 1],T_ns_1)
Y_ns_1 <- ifelse(T_ns_1 == 1, Y1_ns_1, Y0_ns_1)
# plot(Y0_ns_1,Y_ns_1)
save(Y_ns_1,Y1_ns_1,Y0_ns_1,X_ns_1,T_ns_1,ps_ns_1,file="datans1.Rdata")
```

## heteroskadestic and non-linear
The covariates $X_{ij}$ are i.i.d. generated from $\mathrm{Unif}([0, 1])$ , $Y_{i}(0)=\epsilon_{i}$, $\mathbb{E}[Y_{i}(1) \mid X_{i}] = f(X_{i1})f(X_{i2})$ , where $f(x) = \frac{2}{1 + \exp(-12(x - 0.5))}$. $Y_{i}(1) = \mathbb{E}[Y_{i}(1) \mid X_{i}] + \epsilon_{i}$ where $\epsilon_{i}\stackrel{i.i.d.}{\sim}N(0, 1)$. 

The propensity score $e(x)=P(T_{i} = 1\mid X_{i} = x)$ is set as $e(x) = \frac{1}{4}(1 + \beta_{2, 4}(x))$ where $\beta_{2, 4}(x)$ is the cdf of the Beta-distribution with parameters 2 and 4.
```{r data_ns_2}
# non-spatial data, 
# heteroskadestic.
set.seed(123)
n <- 1000
d <- 5
X_ns_2 <- X_ns_1 
genY_ns_2 <- function(X){
  2 / (1+exp(-12*(X[, 1]-0.5)))*2/(1+exp(-12*(X[, 2]-0.5)))+rnorm(n)
  }
Y1_ns_2 <- genY_ns_2(X_ns_2) 
# hist(Y1_ns_2)
# plot(X_ns_2[, 1],Y1_ns_2)
Y0_ns_2 <- rnorm(n)
ps_ns_2 <- (1 + pbeta(X_ns_2[, 1], 2, 4)) / 4
T_ns_2 <- sapply(ps_ns_2,function(x){rbinom(1,1,prob=x)}) 
# plot(X_ns_2[, 1],T_ns_2)
# T_ns_2 <- map_dbl(1:n,function(x){rbernoulli(n=1,ps_ns_2[x])}) 
# T_ns_2 <- as.numeric(ps_ns_2 > runif(n)) 
Y_ns_2 <- ifelse(T_ns_2 == 1, Y1_ns_2, Y0_ns_2)
# plot(Y0_ns_2,Y_ns_2)
save(Y_ns_2,Y1_ns_2,Y0_ns_2,X_ns_2,T_ns_2,ps_ns_2,file="datans2.Rdata")
```


# generating network (spatial) data with interference

Spatial network data is generated in the following way: Step 1. n points are randomly sampled from a unit square. All node pairs within distance band r are connected with an edge. r is chosen such that node degree distribution is reasonable. Coordinates of each pointare saved as node attributes. This creates a spatial network. Step 2. data1 or data2 are combined to the network such that each data point is assigned to a spatial point. 

Following this procedure, the X of the units are spatially random with no autocorrelation or spatial dependence. There is no unmeasured spatial confounding, conditional ignorability still holds. Interference is defined according to the spatial network structure, where each unit's outcome is dependent on its first-order neighbors' treatment. Further, non-stationarity can be introduced in several places, for example, in the determining function of Y, in the dependence between neighbors, or in the treatment propensity.

##  net1. Map data_ns_1 to random network. save potential outcomes.
```{r}
n <- 1000
# generate net1 and map data_ns_1 to net1
# net1 <- sample_gnp(n,p=0.1,directed=FALSE,loops=FALSE) # non-spatial graph
net1<-igraph::sample_grg(n,radius=0.05,torus=FALSE,coords=TRUE) # spatial graph
# saveRDS(net1,file="net1_structure.Rdata") 
# plot(net1,vertex.size = 3,vertex.label = NA)
# hist(degree(net1)) # mostly between 2-12 first-order neighbours
g1 <- igraph::as_data_frame(net1,what="vertices")# coords in (x, y)
colnames(g1)<-c("coordx","coordy")
g1$Z <- T_ns_1
g1$YZ <-Y_ns_1
g1$G <- 0
g1$YG <- 0
for (i in 1:n){
    neigh = igraph::neighbors(net1,v = i)
    g1$G[i] =  mean(g1$Z[neigh]) # mean exposure, can also use inverse dist w
    g1$YG[i] =0.2*mean(g1$YZ[neigh]) # neighborhood spillover YG
}
#hist(g1$YG)

# all POs. technically speaking this is a bit problematic...
YG1_nt_1<-g1$YG
YG0_nt_1<-0
YZ1_nt_1<-Y1_ns_1
YZ0_nt_1<-Y0_ns_1

Y00_nt_1<-YZ0_nt_1+YG0_nt_1
Y01_nt_1<-YZ0_nt_1+YG1_nt_1
Y10_nt_1<-YZ1_nt_1+YG0_nt_1
Y11_nt_1<-YZ1_nt_1+YG1_nt_1

# actual outcome
g1$YG <- ifelse(g1$G >0.5, g1$YG, 0)
Y_nt_1<-g1$YZ+g1$YG # add interference. effects from Z & G assumed additive.
#hist(Y_nt_1)

X_nt_1<-X_ns_1
A_adj<-as_adjacency_matrix(net1)
Z_nt_1<-g1$Z
G_nt_1<-ifelse(g1$G >0.5, 1, 0)
T_nt_1<-paste0("t",Z_nt_1,G_nt_1)

# Compute gps later and check balance.
save(Y00_nt_1,Y01_nt_1,Y10_nt_1,Y11_nt_1,Y_nt_1,X_nt_1,Z_nt_1,G_nt_1,T_nt_1,file="datanet1.Rdata")
```


##  net2. Map data_ns_2 to same random network as net1.save potential outcomes.
```{r}
# map data_ns_2 to net1, with updated Z, G, YZ, YG, Y
g2<-g1
g2$Z <- T_ns_2
g2$YZ <-Y_ns_2
g2$G <- 0
g2$YG <- 0
for (i in 1:n){
    neigh = igraph::neighbors(net1,v = i)
    g2$G[i] =  mean(g2$Z[neigh]) 
    g2$YG[i] =0.2*mean(g2$YZ[neigh]) 
}
# all POs.
YG1_nt_2<-g2$YG
YG0_nt_2<-0
YZ1_nt_2<-Y1_ns_2
YZ0_nt_2<-Y0_ns_2

Y00_nt_2<-YZ0_nt_2+YG0_nt_2
Y01_nt_2<-YZ0_nt_2+YG1_nt_2
Y10_nt_2<-YZ1_nt_2+YG0_nt_2
Y11_nt_2<-YZ1_nt_2+YG1_nt_2

# actual outcome
g2$YG <- ifelse(g2$G >0.5, g2$YG, 0)

Y_nt_2<-g2$YZ+g2$YG 
X_nt_2<-X_ns_2
# A_adj 
Z_nt_2<-g2$Z
G_nt_2<-ifelse(g2$G >0.5, 1, 0)
T_nt_2<-paste0("t",Z_nt_2,G_nt_2)
save(Y00_nt_2,Y01_nt_2,Y10_nt_2,Y11_nt_2,Y_nt_2,X_nt_2,Z_nt_2,G_nt_2,T_nt_2,file="datanet2.Rdata")
```

## net3. add spatial non-stationarity in y=f_beta(x) to net2 outcome YZ.
```{r}
set.seed(123)
# outcome Y_i(Z=1) is dependent on location of i ,
# in the form of spatially varying coeff in generating Y(Z=1)
grid <- expand.grid(1:100, 1:100)
names(grid)<-c("x","y")

# spatial trend
g.dummy1 <- gstat(formula=z~1+x+y, locations=~x+y, dummy=T, beta=c(1,0.01,0.005), model=vgm(psill=0.025, range=15, model='Exp'), nmax=20)
# random clustering
g.dummy2 <- gstat(formula=z~1, locations=~x+y, dummy=T, beta=c(1,0.01,0.005), model=vgm(psill=0.025, range=15, model='Exp'), nmax=20)

coeff_grid <- predict(g.dummy1, newdata=grid, nsim=4)
sp::gridded(coeff_grid) = ~x+y
# saveRDS(coeff_grid,file="coeff_grid.Rdata") 
# spplot(coeff_grid)
sim<-data.frame(coeff_grid$sim1,coeff_grid$sim2,coeff_grid@coords)
colnames(sim)<-c("coeff1","coeff2","x","y")
sim$xy<-paste0(sim$x,"-",sim$y)

coeff<-data.frame(floor(g1$coordx*100)+1,floor(g1$coordy*100)+1)
colnames(coeff)<-c("x","y")
coeff$xy<-paste0(coeff$x,"-",coeff$y)
coeff<-left_join(coeff,sim[,c(1,2,5)],by="xy")

# sanity checks
# mapcheck<-cbind.data.frame(coeff$x,coeff$y,X_ns_1,Z_nt_3,G_nt_3,Y_nt_3)
# ggplot(coeff,aes(x=x,y=y,color=coeff1))+geom_point(size=3)+scale_colour_gradient2()

genY_nt_3 <- function(X){
  2 / (1 + exp(coeff$coeff1*(X[, 1]-0.5)))*2/(1 + exp(-1 *(X[, 2] - 0.5)))+rnorm(n)
}
YZ1_nt_3 <- genY_nt_3(X_ns_2) 
# hist(Y1_nt_3)
# plot(X_ns_2[,1],Y1_nt_3)
YZ_nt_3 <- ifelse(T_ns_2 == 1, YZ1_nt_3, Y0_ns_2)
# copy net1, with updated YZ, YG, Y
g3<-g1
g3$YZ <-YZ_nt_3
for (i in 1:n){
    neigh = igraph::neighbors(net1,v = i)
    g3$YG[i] =0.2*mean(g3$YZ[neigh])
}
# all POs.
YG1_nt_3<-g3$YG
YG0_nt_3<-0
#YZ1_nt_3
YZ0_nt_3<-Y0_ns_2

Y00_nt_3<-YZ0_nt_3+YG0_nt_3
Y01_nt_3<-YZ0_nt_3+YG1_nt_3
Y10_nt_3<-YZ1_nt_3+YG0_nt_3
Y11_nt_3<-YZ1_nt_3+YG1_nt_3

# actual outcome
g3$YG <- ifelse(g3$G >0.5, g3$YG, 0)

Y_nt_3<-g3$YZ+g3$YG
X_nt_3<-X_ns_2
# A_adj
Z_nt_3<-g3$Z
G_nt_3<-ifelse(g3$G >0.5, 1, 0)
T_nt_3<-paste0("t",Z_nt_3,G_nt_3)
save(Y00_nt_3,Y01_nt_3,Y10_nt_3,Y11_nt_3,Y_nt_3,X_nt_3,Z_nt_3,G_nt_3,T_nt_3,file="datanet3.Rdata")
```


(4) net4. With network autocorrelation. This may affect the design of conformal prediction (As long as sampling is random, exchangeability still approximately holds. If there's a spatial pattern in Y, modeling it may help increase outcome prediction accuracy in the face of unmeasured spatial confounding ). Otherwise it should not make a difference for causal identification, since we assume conditional ignorability.
```{r}

```


# testing the estimation of GPS

```{r testid}
# testing point, one index from 1:n
testid0<- sample(n,1) # 832
```


```{r test1}
# binary treatment, 4 level exposure, getting GPS and test balance
A<-as.matrix(A_adj)

# glm predictions
test1_gps1 <- get_gps1(tr = Z_nt_1,covar = X_nt_1,A = A,Atype="adj",
                    pstype="joint",ps_pred_model="binomial")
# check p(z=1) 
hist(test1_gps1[,5]) # should be roughly uniform[0,1]
plot(ps_ns_1,test1_gps1[,5],xlab="True Z",ylab="Estimated Z") # pretty close
# check p(g=1)
# p(g=1) should roughly center around 0.5, because neighborhood assignment and spatial distribution of Z is random.
hist(test1_gps1[,6]) # a bit flat
# check gps and balance
hist(test1_gps1[,1]) # why this shape?
# nnet::multinom predictions
test1_gps2 <- get_gps1(tr = Z_nt_1,covar = X_nt_1,A = A,Atype="adj",
                    pstype="joint",ps_pred_model="multinom")
plot(test1_gps1[,1],test1_gps2[,1]) # t11, t10 very close. t01 t00 not so much
check<-data.frame(T_nt_1,test1_gps3) # T predictions only 50% accurate

```


# Testing standard split conformal prediction


```{r test2,  include=TRUE, eval=FALSE}
# generate null equal weights and random trainid
test2_wt<-rep(1,n)
test2_trainid<-sample(n,floor(n*0.6))
test2Xtest<-as.data.frame(X_ns_1[testid0,,drop=FALSE])
test2wttest<-1
#r1<-randomForest(x=X_ns_1, y=Y_ns_1)
#res <- predict(r1, newdata = X_ns_1)
#plot(Y_ns_1,res)
#r2<-grf::quantile_forest(X_ns_1, Y_ns_1,quantiles=c(0.1,0.9))
#res2 <- predict(r2, X_ns_1,quantiles=c(0.1,0.9))
#res2 <-res2$predictions

# Mean pred
test2_pred <- conformalSplit(X=X_ns_1, Y=Y1_ns_1, test2Xtest,test2wttest,
                          outfun="RF", 
                          wt=test2_wt,CQR=FALSE,
                          trainid=test2_trainid,
                          alpha=0.1)
# -5.245218 [-3.468821, -3.466433]
# -2.179215 [-1.744514, -1.742704]
# a bit off

# QR

test2_pred <- conformalSplit(X=X_ns_1, Y=Y1_ns_1, test2Xtest,test2wttest,
                          outfun="QRF", 
                          wt=test2_wt,CQR=TRUE,
                          trainid=test2_trainid,
                          alpha=0.1)
# 3.558138 [3.832819，	1.205149	]
# -2.179215 [-0.3682066，	-2.182044]
# a bit conservative, but covers the true value
```


# Testing spatial conformal 

## testing the counterfactual prediction
```{r test3_trainid}
# generate different trainid, if desired.
test3_trainid
test4_trainid
test5_trainid
# needs to be list of 4. vaid for subgroup of each tl level.
```


```{r}
# generate gps
ps_nt_1 <-test1_gps1

ps_nt_2 <- get_gps1(tr = Z_nt_2,covar = X_nt_2, A = A,Atype="adj",
                    pstype="joint",ps_pred_model="binomial")
ps_nt_3 <- get_gps1(tr = Z_nt_3,covar = X_nt_3,A = A,Atype="adj",
                    pstype="joint",ps_pred_model="binomial")
```


spatial linear
```{r test3}
# spatial CF for counterfactual prediciton
# trainid generated randomly in each tl level.

# testid0 694
X_nt_1Xtest <- X_nt_1[694, ,drop=FALSE]
Y_nt_1Ytest <- Y_nt_1[694]
t_nt_1tltest <- T_nt_1[694]
ps_nt_1wttest <- ps_nt_1[694,4]

test3_pred <- conformalCf_split(X=X_nt_1, Y=Y_nt_1, 
                              X_nt_1Xtest,Y_nt_1Ytest,t_nt_1tltest,ps_nt_1wttest,
                              tl=T_nt_1,
                              outfun="QRF", CQR=TRUE,
                              ps=ps_nt_1, trainid=NA) 

test3_pred[[1]] # t11 [-0.6797705	-0.5132873]
test3_pred[[2]] # t10 [-0.2833406	-0.243811]
test3_pred[[3]] # t01 [0.6533025	0.6595292]
test3_pred[[4]] # t00 [-0.5793577	-0.5793577] observed

```

spatial heteroskadestic
```{r test4}
# spatial CF for counterfactual prediciton

X_nt_2Xtest <- X_nt_2[694, ,drop=FALSE]
Y_nt_2Ytest <- Y_nt_2[694]
t_nt_2tltest <- T_nt_2[694]
ps_nt_2wttest <- ps_nt_2[694,4]

test4_pred<-conformalCf_split(X=X_nt_2, Y=Y_nt_2, 
                              X_nt_2Xtest,Y_nt_2Ytest,t_nt_2tltest,ps_nt_2wttest,
                              tl=T_nt_2,
                              outfun="QRF", CQR=TRUE,
                              ps=ps_nt_2, trainid=NA)
# 1.075921	1.075921	1.870428	0.5288074	0.2933692	0.3045858	0.6052872 -0.5387912
```

spatial heteroskadestic, non-stationary
```{r test5}
# spatial CF for counterfactual prediciton

X_nt_3Xtest <- X_nt_3[694, ,drop=FALSE]
Y_nt_3Ytest <- Y_nt_3[694]
t_nt_3tltest <- T_nt_3[694]
ps_nt_3wttest <- ps_nt_3[694,4]

test5_pred<-conformalCf_split(X=X_nt_3, Y=Y_nt_3, 
                              X_nt_3Xtest,Y_nt_3Ytest,t_nt_3tltest,ps_nt_3wttest,
                              tl=T_nt_3,
                              outfun="QRF", CQR=TRUE,
                              ps=ps_nt_3, trainid=NA)
# 0.8366873	0.7176229	0.361684	0.2161662	0.6662771	0.3251723 2.564196	2.564196
```


## testing the spatial ITE construction

computing coverage rate
For computing coverage, experiments are rerun 100 times. Plot the confidence intervals against true value as summary the coverage.
We compute coverage rates on the main advertised scenarios: 
test6 (spatial linear) 
test7 (spatial heteroskadestic) 
test8 (spatial heteroskadestic non-stationary).

To do:
The functions need to be modified to take a list of prediction point indices.

```{r}
# test6
test6_pred1 <-conformal_ITE1(X=X_nt_1, Y=Y_nt_1, 
                              testid=c(694,843),
                              tr=Z_nt_1,
                              A=A,Atype="adj",
                              ps_pred_model="binomial",
                              outfun="RF", CQR=FALSE,
                              retrainYmodel=TRUE) 

# retrainYmodel=FALSE has got an issue !

# -0.6418318  -0.6074899  1.290484  1.306998  -1.397166  -1.351036  0.5469377 0.5516644
# -0.3038072  -0.2572891  -1.483445  -1.450133  3.653244  3.723609  2.4974531 2.5069188
```


```{r compute_coverage}
# repeat this experiment 100 times:
# for a single run, input a list of testid, calculate one coverage rate from output.

# either the Ymodel is only fitted once and a list of testid are fed to the model, 
# or the Ymodel is fitted again each time a new test point is supplied.

# ! atm use retrainYmodel=TRUE, so that the order of outputs will not be scrambled.

testid6 <- sample(1000,10) 
  
test6_res<-conformal_ITE1(X=X_nt_1, Y=Y_nt_1, 
                              testid=testid6,
                              tr=Z_nt_1,
                              A=A,Atype="adj",
                              ps_pred_model="binomial",
                              outfun="RF", CQR=FALSE,
                              retrainYmodel=TRUE)
test6_PO <- test6_res[[1]]

# check prediction against 'true' (as in one realisation of) PO
# test6_tl<-T_nt_3[testid6] 
test6_Y <- data.frame(Y11=Y11_nt_1[testid6],
                      Y10=Y10_nt_1[testid6],
                      Y01=Y01_nt_1[testid6],
                      Y00=Y00_nt_1[testid6])

# coverage rate is 0
cov1 <- test6_PO[,2]-test6_PO[,1] - max(abs(test6_Y [,1]-test6_PO[,1]),
                                            abs(test6_Y [,1]-test6_PO[,2]))
which(cov1>0) # 0 correct coverage

cov2 <- test6_PO[,4]-test6_PO[,3] - max(abs(test6_Y [,2]-test6_PO[,3]),
                                            abs(test6_Y [,2]-test6_PO[,4]))
which(cov2>0)

cov3 <- test6_PO[,6]-test6_PO[,5] - max(abs(test6_Y [,3]-test6_PO[,5]),
                                            abs(test6_Y [,3]-test6_PO[,6]))
which(cov3>0)

cov4 <- test6_PO[,8]-test6_PO[,7] - max(abs(test6_Y [,4]-test6_PO[,7]),
                                            abs(test6_Y [,4]-test6_PO[,8]))
which(cov4>0)

```


```{r plot1 }
# plotting coverage of test6


```

