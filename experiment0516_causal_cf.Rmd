---
title: "experiment0516_causal_cf"
author: "mira"
date: "16/05/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(tidyverse)
library(ggplot2)
library(viridis)
library(argparse)
library(grf)
library(gbm)
library(randomForest)
library(bartMachine)
library(causalToolbox)

```



# conformal prediction for individual treatment effect

ref: 
Lei, L. & Candes, E. (2021) Conformal Inference of Counterfactuals and Individual Treatment Effects. arXiv:2006.06138v2 
https://github.com/lihualei71/cfcausal
https://github.com/lihualei71/cfcausalPaper

Jin, Y. (2022) Sensitivity Analysis of Individual Treatment Effects: A Robust Conformal Inference Approach. arXiv:2111.12161v2 
https://github.com/zhimeir/cfsensitivity
https://github.com/ying531/cfsensitivity_paper

causalToolbox https://github.com/forestry-labs/causalToolbox
function calls to causalToolbox :X_RF



## conformal ITE data preparations

```{r prep synthetic data,  include=TRUE, eval=FALSE}
# Read NLSM data
data <- read.csv("../data/NLSM_data.csv")
X <- data %>% select(-Z, -Y) %>% as.matrix
Y <- data$Y
T <- data$Z
n <- length(Y)

# Data splitting
set.seed(123)
tmp <- sample(n, n)
ntrain <- ceiling(0.2 * n)
trainid <- tmp[1:ntrain]
valid <- tmp[(ntrain + 1):n]

Xtrain <- X[trainid, ]
Ytrain <- Y[trainid]
Ttrain <- T[trainid]

Y1 <- Ytrain[Ttrain == 1]
X1 <- Xtrain[Ttrain == 1, ]
Y0 <- Ytrain[Ttrain == 0]
X0 <- Xtrain[Ttrain == 0, ]

X <- X[-trainid, ]

# Set \tau(x) based on Section 2 of Carvalho et al. [2019]
gamma <- rnorm(76) * 0.105
Etau <- 0.228 +
        0.05 * (X[, 7] < 0.07) -
        0.05 * (X[, 8] < -0.69) -
        0.08 * (X[, 3] %in% c(1, 13, 14)) + 
        gamma[X[, 1]]

# Fit models and predict Y0
# ref cfcausal functions {RF}  {quantRF}
EY0 <- cfcausal:::RF(Y0, X0, X)
IQR0 <- cfcausal:::quantRF(Y0, X0, X, quantiles = c(0.25, 0.75))
IQR0 <- IQR0[, 2] - IQR0[, 1]
IQR1 <- cfcausal:::quantRF(Y1, X1, X, quantiles = c(0.25, 0.75))
IQR1 <- IQR1[, 2] - IQR1[, 1]
ps <- cfcausal:::RF(as.factor(Ttrain), Xtrain, X)
ps <- pmin(pmax(ps, 0.1), 0.9)

# Store the data
data <- list(X = X, EY0 = EY0, Etau = Etau, IQR0 = IQR0, IQR1 = IQR1, ps = ps)
save(data, file = "../data/NLSM_simul.RData")
```



## Utils and helper funcs
```{r utils score idlist wtcutoff, include=TRUE, eval=FALSE}
# conformal score. for conformalCV main func
conformalScore <- function(Y, Yhat, type, side){
        if (type == "CQR" && side == "two"){
            score <- pmax(Yhat[, 1] - Y, Y - Yhat[, 2])
        } else if (type == "mean" && side == "two"){
            score <- abs(Yhat - Y)
        } else if (side == "above"){
            score <- Y - Yhat
        } else if (side == "below"){
            score <- Yhat - Y
        }
    return(score)
}

## Generate a list of indices for cross-validation. for conformalCf_CV & conformalCV main func
gen_cv_ids <- function(n, nfolds, offset = 0){
    ids <- sample(n, n)
    quo <- floor(n / nfolds)
    resid <- n - quo * nfolds
    idlist <- lapply(1:nfolds, function(i){
        tmp <- (i - 1) * quo + 1:quo
        if (i <= resid){tmp <- c(tmp, quo * nfolds + i)}
        return(ids[tmp] + offset)}
    )
    return(idlist)
}

# weight conformal cutoff, for conformalCV main func
weightedConformalCutoff <- function(score, weight, qt){
    ord <- order(score)
    weight <- weight[ord]
    score <- score[ord]
    cw <- cumsum(weight)
    inds <- find_inds(cw, qt)    
    cutoff <- score[inds]
    return(cutoff)
}
```


```{r outfun RF, include=TRUE, eval=FALSE}
## wrapper for randomForest::randomForest
RF <- function(Y, X, Xtest, ...){
    # depending on the class of Y being continuous or binomial
    # if continuous
    fit <- randomForest::randomForest(x = X, y = Y, ...)
    res <- predict(fit, newdata = Xtest)
    res <- as.numeric(res)
    # can be extended to other cases ...
    return(res)
}
```


```{r outfun quantile RF, include=TRUE, eval=FALSE}
## quantile random forest. wrapper for grf::quantile_forest 
quantRF <- function(Y, X, Xtest, quantiles, ...){
    fit <- grf::quantile_forest(X, Y, quantiles = quantiles, ...)
    res <- predict(fit, Xtest, quantiles = quantiles)
    if (length(quantiles) == 1){
        res <- as.numeric(res)
    } else {
        res <- as.matrix(res)
    }
    return(res)
}
```


```{r psfun Boosting, include=TRUE, eval=FALSE}
## wrapper for gbm::gbm 
Boosting <- function(Y, X, Xtest, n.trees = 100, ...){
   # X Xtest should be dataframes
   # suppose Y is binomial (in the use case of {/psfun} for binary treatment )
    if (is.factor(Y)){Y <- as.numeric(Y)-1}
    data <- data.frame(Y = Y, X)
    fit <- gbm::gbm(Y ~ ., distribution = distribution, data = data, n.trees = n.trees, ...)
    res <- predict(fit, Xtest, type = "response", n.trees = n.trees)

    return(res)
}
```


## Main funcs
```{r conformal_CV, include=TRUE, eval=FALSE}
# conformalCV 
# type ==CQR, both sides, quantiles=(0.05, 0.95)

# params
# X testing set 
# Y
# outfun
# outparams list of other params for the outfun, e.g. see {\quantRF}
# wtfun weight function
# nfolds
# idlist
# Xtest testing covariates.
# alpha confidence level.
# wthigh upper truncation
# wtlow lower truncation. extreme weights are truncated to ensure stability.

# return predictive intervals. n*2 data.frame 

conformalCV <- function(X, Y, outfun, outparams,wtfun, nfolds, idlist,
                        Xtest,alpha = 0.1,wthigh = 20, wtlow = 0.05){
   
   wtfun0 <- NULL
    if (is.null(wtfun)){
        wtfun <- lapply(1:nfolds, function(k){function(X){rep(1, nrow(X))}})
    } else if (is.function(wtfun)){
        wtfun0 <- wtfun
        wtfun <- rep(list(wtfun), nfolds)
    } 
    if (is.null(wtfun0)){wtfun0 <- wtfun}
    
    outparams <- c(outparams, list(quantiles = c(0.05, 0.95)))
    outparams0 <- outparams
    n <- length(Y)
    idlist <- gen_cv_ids(n, nfolds)

    temp <- list()
    for (k in 1:nfolds){
        testid <- idlist[[k]]
        Xtrain <- X[-testid, ,drop=FALSE]
        Ytrain <- Y[-testid]
        Xval <- X[testid, ,drop=FALSE]
        Yval <- Y[testid]

        outparams <- c(list(Y = Ytrain, X = Xtrain), outparams0)
        
        Ymodel <- function(X){do.call(outfun, c(outparams, list(Xtest = X)))}
        Yhat <- Ymodel(Xval)
        Yhat_test <- Ymodel(Xtest)
        Yscore <- conformalScore(Yval, Yhat, type, side)
       
        wt <- wtfun[[k]](Xval)

        temp[[k]] <- list(Yscore = Yscore,
                    wt = wt,
                    Ymodel = Ymodel
                    Yhat_test = Yhat_test)
    }
                                
    # CV prediction
    censoring <- function(x, high = 20, low = 0.05){pmin(pmax(x, low), high)}
    
    wt <- do.call(c, lapply(temp, function(x){x$wt}))
    wt_test <- wtfun(Xtest)
    avg_wt <- mean(c(wt, wt_test))
    wt <- censoring(wt / avg_wt, wthigh, wtlow)
    wt_test <- censoring(wt_test / avg_wt, wthigh, wtlow)

    totw <- sum(wt)
    wt <- wt / totw
    qt <- (1 + wt_test / totw) * (1 - alpha)
    qt <- pmin(qt, 1)
    
    # the confidence intervals
    CI <- sapply(1:length(qt), function(i){
        Ylo <- lapply(temp, function(x){x$Yhat_test[i, 1] - x$Yscore})
        Ylo <- do.call(c, Ylo)
        Ylo <- -weightedConformalCutoff(-Ylo, wt, qt[i])
        Yup <- lapply(temp, function(x){x$Yhat_test[i, 2] + x$Yscore})
        Yup <- do.call(c, Yup)
        Yup <- weightedConformalCutoff(Yup, wt, qt[i])
        c(Ylo, Yup)
    })
    res <- data.frame(lower = as.numeric(CI[1, ]),upper = as.numeric(CI[2, ]))
    
    return(res)
}
```


```{r conformalCf_CV, include=TRUE, eval=FALSE}
# estimand == missing, type==CQR, both sides, quantile (0.05, 0.95)

# params:
# Xï¼Œ Y
# outfun
# outparams
# psfun
# psparams
# nfolds
# returns CI (from conformalCV)
conformalCf_CV <- function(X, Y,outfun, outparams,psfun, psparams,nfolds){
  
    T <- as.numeric(!is.na(Y))
    inds1 <- which(T == 1)
    inds0 <- which(T == 0)
    n1 <- length(inds1)
    n0 <- length(inds0)

    idlist1 <- gen_cv_ids(n1, nfolds, offset = 0)
    idlist0 <- gen_cv_ids(n0, nfolds, offset = 0)
    idlist <- lapply(1:nfolds, function(k){
      c(inds1[idlist1[[k]]], inds0[idlist0[[k]]])
    })

    psparams0 <- psparams
    wtfun <- lapply(1:nfolds, function(k){
        testid <- idlist[[k]]
        Xtrain <- X[-testid, ,drop=FALSE]
        Ttrain <- T[-testid]
        psparams <- c(list(Y = Ttrain, X = Xtrain), psparams0)
        function(X){
            ps <- do.call(psfun, c(psparams, list(Xtest = X)))
            (1 - ps) / ps
        }
    })
    psparams <- c(list(Y = T, X = X), psparams0)
    wtfun_test <- function(X){
        ps <- do.call(psfun, c(psparams, list(Xtest = X)))
        (1 - ps) / ps
    }

    X <- X[inds1, ,drop=FALSE]
    Y <- Y[inds1]
    
    # get CI form conformalCV(X, Y, outfun, outparams,wtfun, nfolds, idlist,Xtest)
    res <- conformalCV(X, Y,outfun, outparams,wtfun, nfolds, idlist1)
    #res$wtfun <- wtfun_test
    return(res)
}
```


```{r conforalIte by conformalCf_CV, include=TRUE, eval=FALSE}
# Naive methods of Conformal inference for individual treatment effects for subjects with both missing potential outcome. 
# CV conformal pred, two sided, quantiles (0.05, 0.95), type==CQR
# params
# X covariates
# Y outcome vector with missing values encoded as NA
# T
# outfun
# outparams
# psfun
# psparams
# nfolds
# Xtest
# alpha
# wthigh
# wtlow
# return ITE predction intervals

conformalIte <- function(X, Y, T,outfun, outparams,
                              psfun, psparams,nfolds,
                              Xtest, alpha = 0.1,wthigh = 20, wtlow = 0.05){
    Y1 <- Y0 <- Y
    Y1[T == 0] <- NA
    Y0[T == 1] <- NA
    inds <- which(T == 1)

    # call conformalCf_CV (conformalCV) to make the counterfactual predictions
    # take the difference as ITE estimate
    Y1_CI <- conformalCf_CV(X, Y,outfun, outparams,psfun, psparams,nfolds)
    Y0_CI <- conformalCf_CV(X, Y,outfun, outparams,psfun, psparams,nfolds)

    CI <- data.frame(lower = Y1_CI[, 1] - Y0_CI[, 2],upper = Y1_CI[, 2] - Y0_CI[, 1])

    return(CI)
}
```


## demonstration of func use
```{r demon setup, include=TRUE, eval=FALSE}
# CF for counterfactuals
# Generate data
set.seed(123)
n <- 1000
d <- 5
X <- matrix(rnorm(n * d), nrow = n) # 1000*5
beta <- rep(1, 5)

# Y with missing vals
Y2 <- X %*% beta + rnorm(n) # 1000*1
missing_prob <- pnorm(X[, 1]) 
if_missing <- missing_prob < runif(n) 
Y2[if_missing] <- NA
sum(is.na(Y2)) # 517

# Y with random treatment
Y1 <- X %*% beta + rnorm(n)
Y0 <- rnorm(n)
ps <- pnorm(X[, 1]) # propensity
T <- as.numeric(ps < runif(n))
Y <- ifelse(T == 1, Y1, Y0)

# Generate testing data
ntest <- 5
Xtest <- matrix(rnorm(ntest * d), nrow = ntest) # 5*5
```


```{r demon 1 Cf,  include=TRUE, eval=FALSE}
# CF for counterfactuals

# Run weighted CQR-CV
conformalCf_CV(X, Y2, psfun="Boosting", outfun = "quantRF",nfolds=4)

```


```{r demon 2 ITE,  include=TRUE, eval=FALSE}
# CF for ITE
# Naive method, CV, 
CI <- conformalIte(X, Y, T, 
                   psfun="Boosting", outfun = "quantRF",
                   nfolds=4,Xtest)


# Counterfactual method, Y and T needs to be observed
#pstest <- pnorm(Xtest[, 1])
#Ttest <- as.numeric(pstest < runif(ntest))
#Y1test <- Xtest %*% beta + rnorm(ntest)
#Y0test <- rnorm(ntest)
#Ytest <- ifelse(Ttest == 1, Y1test, Y0test)
#CI <- conformalIte2(X, Y, T, alpha = 0.1, outfun = "quantRF")

```


